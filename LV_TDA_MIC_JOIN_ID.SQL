SELECT 
	STL.LGCY_BUSN_LCAT_ID_NU AS STORE_NUMBER,
	CASE
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 500 AND 1029 THEN 1
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 1030 AND 1359 THEN 2
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 1400 AND 1659 THEN 3
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 1700 AND 1959 THEN 4
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 2000 AND 2359 THEN 5
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 0000 AND 0459 THEN 6
		ELSE 0 END AS DYPT_ID_NU, /* ID number for Daypart, that matches UK needs. Any filtering in MSTR done on Daypart would be quicker for analytical engine (hence for end users) with numerical ID. */
	CASE
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 500 AND 1029 THEN 'Breakfast'
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 1030 AND 1359 THEN 'Lunch'
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 1400 AND 1659 THEN 'Afternoon'
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 1700 AND 1959 THEN 'Dinner'
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 2000 AND 2359 THEN 'Evening'
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 0 AND 459 THEN 'Night'
		ELSE '0' END AS DYPT_DS, /* please notice than not only naming is different but also timing of 'Breakfast' and 'Lunch'. With a need to hard code some rows, I decided it would be better to hard code the rest as allowed to remove one join to daypart lookup. */
	CASE
		WHEN TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24MI') :: INTEGER BETWEEN 0 AND 359 THEN HDR.POS_ORD_DT-1
		ELSE HDR.POS_ORD_DT END AS POS_BUSN_DT_UK, /* UK Business Date definition */
	REGEXP_replace(HDR.POS_DVCE_ID, '[[:alpha:]]') :: INTEGER AS POS_DVCE_ID,
	NULL AS POS_HOLD_TM_SC_QT, /* to be removed as missing in new backend. Left due to cache dependency */
	(DTL.POS_KEY_NET_PRC_AM*DTL.POS_ITM_TOT_QT) AS POS_ITM_NET_AM,
	DTL.POS_ITM_NET_UNT_PRC_AM,
	DTL.POS_ITM_TOT_QT,
	DTL.POS_ITM_UNT_FOOD_COST_AM,
	DTL.POS_ITM_UNT_PAPR_COST_AM,
	EXTRACT(HOUR FROM HDR.POS_ORD_BEG_TM) AS HOURNUM24,
	CAST('1900-01-01' || ' ' || SPLIT_PART((DATE_TRUNC('hour', HDR.POS_ORD_BEG_TM) + DATE_PART(MIN, HDR.POS_ORD_BEG_TM) :: INTEGER / 15 * INTERVAL '15 min'),' ',2) :: CHAR(8) AS TIMESTAMP) AS POS_ORD_BEG_TS_15M, /* round timestamps to 15 minutes and remove date sensitivity to enable in memory pivoting on 15 min chunks for different dates */
	HDR.POS_ORD_DT,
	HDR.POS_ORD_KEY_ID AS POS_TRN_ID,
	JID.JOIN_ID,
	HDR.POS_ORD_NU,
	DTL.POS_TRN_ITM_LN_SEQ_NU AS POS_TRN_ITM_SEQ_NU,
	DTL.SLD_MENU_ITM_ID,
	CASE
		WHEN HDR.POS_DVCE_ID = 'POS0063' THEN '100'
		WHEN FTIDLV.POS_ORD_KEY_ID IS NOT NULL THEN '101'
	ELSE HDR.TERR_POS_AREA_CD END AS TERR_POS_AREA_CD,
	CASE 
		WHEN HDR.POS_DVCE_ID = 'POS0063' THEN 'MOBILE'
		WHEN FTIDLV.POS_ORD_KEY_ID IS NOT NULL THEN 'DELIVERY'
		WHEN HDR.TERR_POS_AREA_CD = 1 THEN 'FRONT COUNTER'
		WHEN HDR.TERR_POS_AREA_CD = 2 THEN 'DRIVE THRU'
		WHEN HDR.TERR_POS_AREA_CD = 4 THEN 'WALK THRU'
		WHEN HDR.TERR_POS_AREA_CD = 8 THEN 'DELIVERY'
		WHEN HDR.TERR_POS_AREA_CD = 16 THEN 'COLD KIOSK'
		WHEN HDR.TERR_POS_AREA_CD = 32 THEN 'MCCAFE'
		WHEN HDR.TERR_POS_AREA_CD = 64 THEN 'MCEXPRESS'
		WHEN HDR.TERR_POS_AREA_CD = 128 THEN 'COLD KIOSK DRINKS'
		WHEN HDR.TERR_POS_AREA_CD = 90 THEN 'KIOSK'
		WHEN HDR.TERR_POS_AREA_CD = 91 THEN 'HOT'
	ELSE 'UNKNOWN CODE' END AS TERR_POS_AREA_DS, -- custom UK names
	HDR.POS_TRN_KIND_TYP_ID :: CHAR(1) AS TERR_POS_TRN_TYP_CD, /*remove conversion before republishing ALL cubes with it. Can't be done for one as blending would not work */
	PTT.POS_TRN_KIND_TYP_ID AS POS_TRN_TYP_ID,
	PTT.POS_TRN_KIND_TYP_DS AS TERR_POS_TRN_TYP_DS,
	HDR.TERR_PRD_DLVR_METH_CD,
	PDM.TERR_PRD_DLVR_METH_DS,
	CASE	
		WHEN HDR.POS_DVCE_ID = 'POS0063' THEN '2' /* for mobile payments to go to cashless*/
		WHEN HDR.TERR_PYMT_METH_CD BETWEEN 0 AND 2 THEN '1'
		WHEN HDR.TERR_PYMT_METH_CD IN(5,21,22,23) THEN '2'
		WHEN HDR.TERR_PYMT_METH_CD = 6 THEN '3'
		WHEN HDR.TERR_PYMT_METH_CD = 15 THEN '4'
		WHEN HDR.TERR_PYMT_METH_CD = 7 THEN '5'
	ELSE HDR.TERR_PYMT_METH_CD END AS PYMT_METH_TYP_ID, /*ID for 'Payment Method' dimension. To speed up in memory analysis */
	CASE
		WHEN HDR.POS_DVCE_ID = 'POS0063' THEN 'Cashless' /* mobile */
		WHEN HDR.TERR_PYMT_METH_CD = 6 THEN 'Luncheon Voucher'
		WHEN HDR.TERR_PYMT_METH_CD = 15 THEN '£5 Voucher'
		WHEN HDR.TERR_PYMT_METH_CD = 7 THEN 'Cheque'
		WHEN HDR.TERR_PYMT_METH_CD BETWEEN 0 AND 2 THEN 'Cash'
		WHEN HDR.TERR_PYMT_METH_CD IN(5,21,22,23) THEN 'Cashless'
	ELSE 'UNKNOWN CODE' END AS PYMT_METH_TYP_DS, /* description for 'Payment Method' dimension */
	1 AS ROW_COUNT
FROM PROD_TABLES.POS_TRN_LVL_HDR HDR JOIN PROD_TABLES.POS_TRN_LVL_DTL DTL ON  DTL.TERR_CD = HDR.TERR_CD 
 and DTL.MCD_GBAL_LCAT_ID_NU = HDR.MCD_GBAL_LCAT_ID_NU 
 and DTL.POS_ORD_KEY_ID = HDR.POS_ORD_KEY_ID 
 and DTL.POS_BUSN_DT = HDR.POS_BUSN_DT 
 and DTL.POS_EVNT_TYP_ID = HDR.POS_EVNT_TYP_ID
	JOIN PROD_TABLES.MCD_GBAL_BUSN_LCAT STL ON (HDR.MCD_GBAL_LCAT_ID_NU = STL.MCD_GBAL_LCAT_ID_NU)
	JOIN PROD_TABLES.POS_TRN_KIND_TYP_DIM PTT ON (HDR.POS_TRN_KIND_TYP_ID = PTT.POS_TRN_KIND_TYP_ID) 
	JOIN PROD_TABLES.TERR_PRD_DLVR_METH_DIM PDM ON (HDR.TERR_PRD_DLVR_METH_CD = PDM.TERR_PRD_DLVR_METH_CD) AND (HDR.TERR_CD = PDM.TERR_CD)
		LEFT JOIN (SELECT POS_ORD_KEY_ID, POS_BUSN_DT 
					FROM PROD_TABLES.POS_TRN_LVL_DTL 
					WHERE SLD_MENU_ITM_ID = 7499 /* AND POS_BUSN_DT='2018-01-05' AND MCD_GBAL_LCAT_ID_NU=195500092676 AND TERR_CD=826 */) FTIDLV ON (HDR.POS_BUSN_DT = FTIDLV.POS_BUSN_DT) 
															AND (HDR.POS_ORD_KEY_ID = FTIDLV.POS_ORD_KEY_ID) /* delivery POS */
		LEFT JOIN (SELECT
					HDR.POS_ORD_KEY_ID,
					TRIM(STL.LGCY_BUSN_LCAT_ID_NU) || TRIM(TO_CHAR(HDR.POS_ORD_DT, 'DDMMYY')) || TRIM (REGEXP_replace(HDR.POS_DVCE_ID, '[[:alpha:]]') :: INTEGER) || TRIM(TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24') :: INTEGER) || TRIM(ROUND(SQRT(TO_CHAR(HDR.POS_ORD_BEG_TM, 'MI') :: INTEGER),0)) || TRIM(ROUND(HDR.POS_TOT_GRSS_TRN_AM*100,2) :: INTEGER) AS JOIN_ID 
				FROM PROD_TABLES.POS_TRN_LVL_HDR HDR 
					JOIN PROD_TABLES.MCD_GBAL_BUSN_LCAT STL ON (HDR.MCD_GBAL_LCAT_ID_NU = STL.MCD_GBAL_LCAT_ID_NU)
				    JOIN (SELECT NONDUP.JOIN_ID, COUNT(*) AS COUNT_ALL 
				    		FROM (SELECT 
										HDR.POS_ORD_KEY_ID,
										TRIM(STL.LGCY_BUSN_LCAT_ID_NU) || TRIM(TO_CHAR(HDR.POS_ORD_DT, 'DDMMYY')) || TRIM(REGEXP_replace(HDR.POS_DVCE_ID, '[[:alpha:]]') :: INTEGER) || TRIM(TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24') :: INTEGER) || TRIM(ROUND(SQRT(TO_CHAR(HDR.POS_ORD_BEG_TM, 'MI') :: INTEGER),0)) || TRIM(ROUND(HDR.POS_TOT_GRSS_TRN_AM*100,2) :: INTEGER) AS JOIN_ID
									FROM PROD_TABLES.POS_TRN_LVL_HDR HDR 
											JOIN PROD_TABLES.MCD_GBAL_BUSN_LCAT STL ON (HDR.MCD_GBAL_LCAT_ID_NU = STL.MCD_GBAL_LCAT_ID_NU)
									WHERE
										HDR.TERR_PYMT_METH_CD IN(5,21,22,23)
										/* AND HDR.POS_TRN_KIND_TYP_ID < 3 */) AS NONDUP 
						GROUP BY 1
						HAVING COUNT(*) = 1) AS NDU ON (TRIM(STL.LGCY_BUSN_LCAT_ID_NU) || TRIM(TO_CHAR(HDR.POS_ORD_DT, 'DDMMYY')) || TRIM(REGEXP_replace(HDR.POS_DVCE_ID, '[[:alpha:]]') :: INTEGER) || TRIM(TO_CHAR(HDR.POS_ORD_BEG_TM, 'HH24') :: INTEGER) || TRIM(ROUND(SQRT(TO_CHAR(HDR.POS_ORD_BEG_TM, 'MI') :: INTEGER),0)) || TRIM(ROUND(HDR.POS_TOT_GRSS_TRN_AM*100,2) :: INTEGER) = NDU.JOIN_ID) 
				WHERE 	HDR.TERR_PYMT_METH_CD IN(5,21,22,23) /* cashless */
					/* AND HDR.POS_TRN_KIND_TYP_ID < 3 */) JID ON (HDR.POS_ORD_KEY_ID = JID.POS_ORD_KEY_ID) /* join to add Join ID (cashless trn-s only) and remove all Join ID-s that exist for more than one transaction */
WHERE DTL.SLD_MENU_ITM_ID < 10000 /* remove 8-digit Menu Item Codes */
/* AND HDR.POS_TRN_KIND_TYP_ID < 3  possibly needed to exclude waste and employee meals */
